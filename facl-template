#!/bin/bash

# Prints to terminal the `setfacl` commands for a specified user on a given directory and its parent directories. 

## EXAMPLE OUTPUT ####################################################
## # Grant write access to the current directory and everything within
##   setfacl -R -m u:netID:rwX,d:u:netID:rwX /scratch/path/to/the/folder
## # Grant only navigation permissions to the parent directories
##   setfacl -m u:netID:--X /scratch/path/to/the
##   setfacl -m u:netID:--X /scratch/path/to
##   setfacl -m u:netID:--X /scratch/path
######################################################################

# Administrators: 
 # Create two softlinks, one name containing "read" and the other "write" (case-insensitive). 
 # Permissions will be configured based on detected script name.
 # If "read" is found, it sets PERMISSIONS to r-X and TYPE to read.
 # If "write" is found, it sets PERMISSIONS to rwX and TYPE to write.
 # If neither is found, it prints an error message and exits.

# Function to print usage
print_usage() {
    echo "Grant ${TYPE} (${PERMISSIONS}) access to the current directory recursively"
    echo " and navigation permissions (--X) to the parent directories"
    echo ""
    echo "Usage: $(basename $0) [-h] [USERS] [DIR]"
    echo "  -h     Display this help message"
    echo "  USERS  The user(s) to set ACL for (comma-separated, default: netID)"
    echo "  DIR    The directory to set ACL on (default: current directory)"
}

# Set PERMISSIONS and TYPE based on the script name
if [[ "${0,,}" == *"read"* ]]; then 
    PERMISSIONS="r-X"
    TYPE="read"
elif [[ "${0,,}" == *"write"* ]]; then 
    PERMISSIONS="rwX" 
    TYPE="write"
else 
    echo "Script name must contain 'read' or 'write' to set permissions." 
    exit 1 
fi

# Check if -h is passed
if [ "$1" == "-h" ]; then
    print_usage
    exit 0
fi

# Check if only one argument is passed
if [ $# -eq 0 ]; then
    USERS="netID"
    DIR=$(pwd)
elif [ $# -eq 1 ]; then
    if [[ "$1" == /* ]]; then
        DIR="$1"
        USERS="netID"
    else
        USERS="$1"
        DIR=$(pwd)
    fi
elif [ $# -eq 2 ]; then
    USERS="$1"
    DIR="$2"
else
    echo "Error: Too many arguments. Expected at most [USERS] [DIR]." >&2
    echo ""
    print_usage # Assuming you have a print_usage function defined
    exit 1
fi

# Convert DIR to $(pwd) if it equals '.'
if [ "$DIR" == "." ]; then
    DIR=$(pwd)
fi

# Verify if the user is valid or "netID"
#if ! id "$USER" &>/dev/null && [ "$USER" != "netID" ]; then
#    echo "User $USER does not exist'."
#    echo ""
#    print_usage
#    exit 1
#fi

# Ensure DIR is a full path
if [[ "$DIR" != /* ]]; then
    echo "DIR must be a full path."
    echo ""
    print_usage
    exit 1
fi

# Function to set ACL for parent directories
set_acl() {
    local user=$1
    local dir=$2
    local parent_dir
    local type=$3
    
    while [[ "$dir" != "/" ]]; do
        parent_dir=$(dirname "$dir")
        if [[ "$(dirname $parent_dir)" == "/" ]]; then
            break
        fi
        echo "  setfacl -m $type:$user:--X $parent_dir"
        dir=$parent_dir
    done
}

# Print the setfacl command for the current directory
echo "# Grant ${TYPE} (${PERMISSIONS}) access to the current directory and everything within"

# Iterate through $USERS and print the setfacl command
IFS=',' read -ra ADDR <<< "$USERS"
for user in "${ADDR[@]}"; do
  echo "  setfacl -R -m u:${user}:${PERMISSIONS},d:u:${user}:${PERMISSIONS} ${DIR}"
done

echo ""
echo "# Grant only navigation permissions to the parent directories"

# Set ACL for parent directories dynamically
IFS=',' read -ra ADDR <<< "$USERS"
for user in "${ADDR[@]}"; do
  set_acl "${user}" "${DIR}" "u"
done
