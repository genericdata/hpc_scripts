#!/bin/bash

# Prints to terminal the `setfacl` commands for a specified user on a given directory and its parent directories. 

## EXAMPLE OUTPUT ####################################################
## # Grant write access to the current directory and everything within
##   setfacl -R -m u:netID:rwX,d:u:netID:rwX /scratch/path/to/the/folder
## # Grant only navigation permissions to the parent directories
##   setfacl -m u:netID:--X /scratch/path/to/the
##   setfacl -m u:netID:--X /scratch/path/to
##   setfacl -m u:netID:--X /scratch/path
######################################################################

# Administrators: 
 # Create two softlinks, one name containing "read" and the other "write" (case-insensitive). 
 # Permissions will be configured based on detected script name.
 # If "read" is found, it sets PERMISSIONS to r-X and TYPE to read.
 # If "write" is found, it sets PERMISSIONS to rwX and TYPE to write.
 # If neither is found, it prints an error message and exits.

# Function to print usage
print_usage() {
    echo "Grant ${TYPE} (${PERMISSIONS}) access to the current directory recursively"
    echo " and navigation permissions (--X) to the parent directories"
    echo ""
    echo "Usage: $(basename $0) [-h] [USERS] [DIR]"
    echo "  -h     Display this help message"
    echo "  USERS  The user(s) to set ACL for (comma-separated, default: netID)"
    echo "  DIR    The directory to set ACL on (default: current directory)"
}

# Set PERMISSIONS and TYPE based on the script name
if [[ "${0,,}" == *"read"* ]]; then 
    PERMISSIONS="r-X"
    TYPE="read"
elif [[ "${0,,}" == *"write"* ]]; then 
    PERMISSIONS="rwX" 
    TYPE="write"
else 
    echo "Script name must contain 'read' or 'write' to set permissions." 
    exit 1 
fi

# Check if -h is passed
if [ "$1" == "-h" ]; then
    print_usage
    exit 0
fi

# Check if only one argument is passed
if [ $# -eq 0 ]; then
    USERS="netID"
    DIR=$(pwd)
elif [ $# -eq 1 ]; then
    if [[ "$1" == /* ]]; then
        DIR="$1"
        USERS="netID"
    else
        USERS="$1"
        DIR=$(pwd)
    fi
elif [ $# -eq 2 ]; then
    USERS="$1"
    DIR="$2"
else
    echo "Error: Too many arguments. Expected at most [USERS] [DIR]." >&2
    echo ""
    print_usage # Assuming you have a print_usage function defined
    exit 1
fi

# Convert DIR to $(pwd) if it equals '.'
if [ "$DIR" == "." ]; then
    DIR=$(pwd)
fi

# Verify if the user is valid or "netID"
#if ! id "$USER" &>/dev/null && [ "$USER" != "netID" ]; then
#    echo "User $USER does not exist'."
#    echo ""
#    print_usage
#    exit 1
#fi

# Ensure DIR is a full path
if [[ "$DIR" != /* ]]; then
    echo "DIR must be a full path."
    echo ""
    print_usage
    exit 1
fi

# Iterate through comma-seperated $USERS 
IFS=',' read -ra ADDR <<< "$USERS"

# Build the ACL entries string
acl_entries=""
num_users=${#ADDR[@]}
for i in "${!ADDR[@]}"; do
  user="${ADDR[$i]}"
  acl_entries+="u:${user}:${PERMISSIONS},d:u:${user}:${PERMISSIONS}"
  if (( i < num_users - 1 )); then
    acl_entries+=","
  fi
done


# Print the setfacl command for the current directory
echo "# Grant ${TYPE} (${PERMISSIONS}) access to the current directory and everything within"
echo """  setfacl -R -m "${acl_entries}" "${DIR}" """ 
echo ""

echo "# Grant only navigation permissions to the parent directories"

acl_entries=""
for i in "${!ADDR[@]}"; do
  user="${ADDR[$i]}"
  acl_entries+="u:${user}:--X"
  if (( i < num_users - 1 )); then
    acl_entries+=","
  fi
done

while [[ "$DIR" != "/" ]]; do
  parent_dir=$(dirname "$DIR")
  if [[ "$(dirname $parent_dir)" == "/" ]]; then
    break
  fi
  echo "  setfacl -m ${acl_entries} ${parent_dir} "
  DIR=$parent_dir
done

